package router

import (
	"net/http"

	_ "alvinlucillo/xyzbooks_webapp/docs" // docs is generated by Swag CLI, you have to import it.
	"alvinlucillo/xyzbooks_webapp/internal/models"
	service "alvinlucillo/xyzbooks_webapp/internal/services"
	"alvinlucillo/xyzbooks_webapp/internal/utils"

	"github.com/go-playground/locales/en"
	ut "github.com/go-playground/universal-translator"
	"github.com/go-playground/validator/v10"
	en_translations "github.com/go-playground/validator/v10/translations/en"
	"github.com/gorilla/mux"
	"github.com/rs/cors"
	"github.com/rs/zerolog"
	httpSwagger "github.com/swaggo/http-swagger/v2"
)

const (
	packageName = "router"

	InvalidIDError = "Invalid id"
)

type Router struct {
	Svc           *service.Service
	Mux           *mux.Router
	Logger        zerolog.Logger
	jsonValidator *validator.Validate
	translator    ut.Translator
}

type ValidationErrors struct {
	Errors []ValidationError `json:"errors"`
}

type ValidationError struct {
	Field   string `json:"field"`
	Message string `json:"message"`
}

type Book struct {
	ID              string    `json:"id"`
	Title           string    `json:"title" validate:"required,max=100"`
	ISBN13          string    `json:"isbn13" validate:"required,len=13,numeric"`
	ISBN10          string    `json:"isbn10" validate:"omitempty,len=10,alphanum"`
	PublicationYear int       `json:"publication_year" validate:"required"`
	Edition         string    `json:"edition" validate:"max=100"`
	Price           float64   `json:"price" validate:"required,numeric"`
	ImageURL        string    `json:"image_url" validate:"max=1000"`
	Publisher       Publisher `json:"publisher" validate:"required"`
	Authors         []Author  `json:"authors" validate:"required,gt=0"`
}

type Author struct {
	ID         string `json:"id"`
	FirstName  string `json:"first_name" validate:"required,max=100"`
	MiddleName string `json:"middle_name" validate:"max=100"`
	LastName   string `json:"last_name" validate:"required,max=100"`
}

type Publisher struct {
	ID   string `json:"id"`
	Name string `json:"name" validate:"required,max=100"`
}

// @title XYZ Books API
// @version 1.0
// @description This is the API documentation for the XYZ Books API.

// @BasePath /api
func NewRouter(svc *service.Service, logger zerolog.Logger) *Router {
	m := mux.NewRouter().StrictSlash(true)

	jsonValidator, translator := NewJSONValidator()

	rt := &Router{
		Svc:           svc,
		Mux:           m,
		Logger:        logger,
		jsonValidator: jsonValidator,
		translator:    translator,
	}

	rt.initRoutes()

	return rt
}

func NewJSONValidator() (*validator.Validate, ut.Translator) {
	en := en.New()
	uni := ut.New(en, en)

	trans, _ := uni.GetTranslator("en")

	validate := validator.New()
	en_translations.RegisterDefaultTranslations(validate, trans)

	return validate, trans
}

func (rt *Router) GetHTTPHandler() http.Handler {
	return cors.AllowAll().Handler(rt.Mux)
}

func (rt *Router) initRoutes() {
	// add tx middleware to init repo
	rt.Mux.Use(func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			rt.Svc.InitRepo()

			next.ServeHTTP(w, r)
		})
	})

	// ready check
	rt.Mux.HandleFunc("/ready", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		w.Write([]byte("Server is ready to accept connections"))
	}).Methods("GET")

	// set base path
	api := rt.Mux.PathPrefix("/api/").Subrouter()

	api.HandleFunc("/books", rt.GetBooks).Methods("GET")
	api.HandleFunc("/books/{isbn13}", rt.GetBookByISBN13).Methods("GET")
	api.HandleFunc("/books", rt.CreateBook).Methods("POST")
	api.HandleFunc("/books/{id}", rt.UpdateBook).Methods("PUT")
	api.HandleFunc("/books/{id}", rt.DeleteBook).Methods("DELETE")

	api.HandleFunc("/authors", rt.GetAuthors).Methods("GET")
	api.HandleFunc("/authors/{id}", rt.GetAuthor).Methods("GET")
	api.HandleFunc("/authors", rt.CreateAuthor).Methods("POST")
	api.HandleFunc("/authors/{id}", rt.UpdateAuthor).Methods("PUT")
	api.HandleFunc("/authors/{id}", rt.DeleteAuthor).Methods("DELETE")

	api.HandleFunc("/publishers", rt.GetPublishers).Methods("GET")
	api.HandleFunc("/publishers/{id}", rt.GetPublisher).Methods("GET")
	api.HandleFunc("/publishers", rt.CreatePublisher).Methods("POST")
	api.HandleFunc("/publishers/{id}", rt.UpdatePublisher).Methods("PUT")
	api.HandleFunc("/publishers/{id}", rt.DeletePublisher).Methods("DELETE")

	api.HandleFunc("/", httpSwagger.WrapHandler).Methods("GET")
	rt.Mux.PathPrefix("/swagger").Handler(httpSwagger.WrapHandler)

	// Redirect the root path to /swagger
	rt.Mux.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		http.Redirect(w, r, "/swagger/", http.StatusMovedPermanently)
	})
}

func (rt *Router) getBookDetails(book models.Book) (float64, Publisher, []Author, error) {
	l := rt.Logger.With().Str("package", packageName).Str("function", "GetBookDetails").Logger()

	var p Publisher
	bookAuthors := []Author{}

	price, _ := book.Price.Float64()

	publisher, err := rt.Svc.Repository.GetPublisher(book.PublisherID)
	if err != nil {
		l.Err(err).Msg("failed to get publisher")
		return price, p, nil, err
	}

	p = Publisher{
		ID:   publisher.ID,
		Name: publisher.Name,
	}

	authors, err := rt.Svc.Repository.GetAuthorBookRelByBookID(book.ID)
	if err != nil {
		l.Err(err).Msg("failed to get authors")
		return price, p, nil, err
	}

	for _, author := range authors {
		a, err := rt.Svc.Repository.GetAuthor(author.AuthorID)
		if err != nil {
			l.Err(err).Msg("failed to get author")
			return price, p, nil, err
		}

		bookAuthors = append(bookAuthors, Author{
			ID:         a.ID,
			FirstName:  a.FirstName,
			MiddleName: a.MiddleName.String,
			LastName:   a.LastName,
		})
	}

	return price, p, bookAuthors, nil
}

func (rt *Router) getHttpCode(err error) int {
	// sql: no rows in result set
	if utils.IsSQLNoRowsErr(err) {
		return http.StatusNotFound
	}

	return http.StatusInternalServerError
}

func (rt Router) getValidationErrors(err error) ValidationErrors {
	errs := err.(validator.ValidationErrors).Translate(rt.translator)

	validationErrors := []ValidationError{}
	for k, v := range errs {
		validationErrors = append(validationErrors, ValidationError{
			Field:   k,
			Message: v,
		})
	}

	return ValidationErrors{validationErrors}
}
